// Рекурсия
// В качестве первого примера напишем функцию pow(x, n), которая возводит x в натуральную степень n.
// Иначе говоря, умножает x на само себя n раз.

// pow(2, 2) = 4
// pow(2, 3) = 8
// pow(2, 4) = 16

// Рассмотрим два способа её реализации.
//
//     Итеративный способ: цикл for:

function pow(x, n) {
  let result = 1;
  // умножаем result на x n раз в цикле
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  return result;
}
alert( pow(2, 3) ); // 8

// Рекурсивный способ: упрощение задачи и вызов функцией самой себя:

    function pow(x, n) {
      if (n == 1) {
        return x;
      } else {
        return x * pow(x, n - 1);
      }
    }

    alert( pow(2, 3) ); // 8

// Обратите внимание, что рекурсивный вариант отличается принципиально.
// Когда функция pow(x, n) вызывается, исполнение делится на две ветви:
//
//               if n==1  = x
//              /
// pow(x, n) =
//              \
//               else     = x * pow(x, n - 1)
//
//      - Если n == 1, тогда всё просто. Эта ветвь называется базой рекурсии,
//           потому что сразу же приводит к очевидному результату: pow(x, 1) равно x.
//      - Мы можем представить pow(x, n) в виде: x * pow(x, n - 1).
//           Что в математике записывается как: xn = x * xn-1. Эта ветвь – шаг рекурсии:
//           мы сводим задачу к более простому действию (умножение на x) и более простой
//           аналогичной задаче (pow с меньшим n). Последующие шаги упрощают задачу всё
//           больше и больше, пока n не достигает 1.
//
// Говорят, что функция pow рекурсивно вызывает саму себя до n == 1.
//
// Например, рекурсивный вариант вычисления pow(2, 4) состоит из шагов:
//
//     pow(2, 4) = 2 * pow(2, 3)
//     pow(2, 3) = 2 * pow(2, 2)
//     pow(2, 2) = 2 * pow(2, 1)
//     pow(2, 1) = 2
//
// Итак, рекурсию используют, когда вычисление функции можно свести к её более простому вызову,
// а его – к ещё более простому и так далее, пока значение не станет очевидно.
// Рекурсивное решение обычно короче
//
// Рекурсивное решение задачи обычно короче, чем итеративное.
// Используя условный оператор ? вместо if, мы можем переписать pow(x, n), делая код функции
// более лаконичным, но всё ещё легко читаемым:

function pow(x, n) {
  return (n == 1) ? x : (x * pow(x, n - 1));
}

// Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии.
// В нашем случае она будет равна ровно n.
// Максимальная глубина рекурсии ограничена движком JavaScript. Точно можно рассчитывать
// на 10000 вложенных вызовов, некоторые интерпретаторы допускают и больше, но для большинства
// из них 100000 вызовов – за пределами возможностей. Существуют автоматические оптимизации,
// помогающие избежать переполнения стека вызовов («оптимизация хвостовой рекурсии»),
// но они ещё не поддерживаются везде и работают только для простых случаев.
//
// Это ограничивает применение рекурсии, но она всё равно широко распространена:
// для решения большого числа задач рекурсивный способ решения даёт более простой код,
// который легче поддерживать.