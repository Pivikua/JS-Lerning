// любой символ даже с идентичным названием уникален
// два символа с одинаковым описанием – но они не равны:

let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false

// Символы не преобразуются автоматически в строки
let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
alert(id.toString()); // Symbol(id), теперь работает
alert(id.description); // id

// можем добавить "скрытые" свойстве к чужим объектам
// чаще всего добавляют идентификаторы

let user = {
    name: "Вася"
};
let id = Symbol("id");
user[id] = 1;
alert( user[id] ); // мы можем получить доступ к данным по ключу-символу

let id = Symbol("id");

// добавление символа в литеральный объект
let user = {
    name: "Вася",
    [id]: 123 // просто "id: 123" не сработает
};

// Символы игнорируются циклом for…in
for (let key in user) alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)

// хотя прямой доступ по символу работает
alert( "Напрямую: " + user[id] );

// Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:
let clone = Object.assign({}, user);

// Существует глобальный реестр символов.
// Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ.