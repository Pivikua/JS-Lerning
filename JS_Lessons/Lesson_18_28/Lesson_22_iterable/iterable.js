// Symbol.iterator

// объект range, который представляет собой диапазон чисел:

let range0 = {
  from: 1,
  to: 5
};

// Мы хотим, чтобы работал for..of:
// for(let num of range) ... num=1,2,3,4,5

// Чтобы сделать range итерируемым (и позволить for..of работать с ним),
// нам нужно добавить в объект метод с именем Symbol.iterator
// (специальный встроенный Symbol, созданный как раз для этого).
//
//     1. Когда цикл for..of запускается, он вызывает этот метод один раз
//          (или выдаёт ошибку, если метод не найден).
//          Этот метод должен вернуть итератор – объект с методом next.
//     2. Дальше for..of работает только с этим возвращённым объектом.
//     3. Когда for..of хочет получить следующее значение, он вызывает метод next() этого объекта.
//     4. Результат вызова next() должен иметь вид {done: Boolean, value: any},
//          где done=true означает, что итерация закончена, в противном случае
//          value содержит очередное значение.
//
// Вот полная реализация range с пояснениями:

let range01 = {
  from: 1,
  to: 5
};

// 1. вызов for..of сначала вызывает эту функцию
range01[Symbol.iterator] = function() {

  // ...она возвращает объект итератора:
  // 2. Далее, for..of работает только с этим итератором, запрашивая у него новые значения
  return {
    current: this.from,
    last: this.to,

    // 3. next() вызывается на каждой итерации цикла for..of
    next() {
      // 4. он должен вернуть значение в виде объекта {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// теперь работает!
for (let num of range01) {
  alert(num); // 1, затем 2, 3, 4, 5
}

// Обратите внимание на ключевую особенность итераторов: разделение ответственности.
//
//     У самого range нет метода next().
//     Вместо этого другой объект, так называемый «итератор»,
//      создаётся вызовом range[Symbol.iterator](), и именно его next() генерирует значения.

let range = {
    from: 1,
    to: 5,
    [Symbol.iterator]() {
        this.current = this.from;
        return this;
    },
    next(){
        if (this.current <= this.to) {
            return {done: false, value: this.current++}
        } else {
            return {done: true};
        }
    }
};

for (let num of range) {
    alert(num);
}

// Итерируемые объекты и псевдомассивы
//
// Есть два официальных термина, которые очень похожи, но в то же время сильно различаются.
// Поэтому убедитесь, что вы как следует поняли их, чтобы избежать путаницы.

//     1. Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator,
//          как было описано выше.
//     2. Псевдомассивы – это объекты, у которых есть индексы и свойство length,
//          то есть, они выглядят как массивы.

// При использовании JavaScript в браузере или других окружениях мы можем встретить объекты,
// которые являются итерируемыми или псевдомассивами, или и тем, и другим.
// Например, строки итерируемы (для них работает for..of) и являются псевдомассивами
// (они индексированы и есть length).
//
//      Но итерируемый объект может не быть псевдомассивом.
//      И наоборот: псевдомассив может не быть итерируемым.
//
// Например, объект range из примера выше – итерируемый, но не является псевдомассивом,
// потому что у него нет индексированных свойств и length.
//
// А вот объект, который является псевдомассивом, но его нельзя итерировать:

let arrayLike = { // есть индексы и свойство length => псевдомассив
    0: "Hello",
    1: "World",
    length: 2
};
// Ошибка (отсутствует Symbol.iterator)
for (let item of arrayLike) {

}

// Array.from
//
// Есть универсальный метод Array.from,
// который принимает итерируемый объект или псевдомассив и делает из него «настоящий» Array.

// синтаксис Array.from позволяет указать необязательную «трансформирующую» функцию:
// Array.from(obj[, mapFn, thisArg])
// Необязательный второй аргумент может быть функцией, которая будет применена к каждому
// элементу перед добавлением в массив, а thisArg позволяет установить this для этой функции.

// Итого
//
// Объекты, которые можно использовать в цикле for..of, называются итерируемыми.
//
//     Технически итерируемые объекты должны иметь метод Symbol.iterator.
//          Результат вызова obj[Symbol.iterator] называется итератором.
//              Он управляет процессом итерации.
//          Итератор должен иметь метод next(), который возвращает объект
//              {done: Boolean, value: any}, где done:true сигнализирует
//              об окончании процесса итерации, в противном случае value – следующее значение.
//     Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его и напрямую.
//     Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод Symbol.iterator.
//     Строковый итератор знает про суррогатные пары.
//
// Объекты, имеющие индексированные свойства и length, называются псевдомассивами.
// Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов.
//
// Если мы заглянем в спецификацию, мы увидим, что большинство встроенных методов рассчитывают
// на то, что они будут работать с итерируемыми объектами или псевдомассивами вместо «настоящих»
// массивов, потому что эти объекты более абстрактны.
//
// Array.from(obj[, mapFn, thisArg]) создаёт настоящий Array из итерируемого объекта
// или псевдомассива obj, и затем мы можем применять к нему методы массивов.
// Необязательные аргументы mapFn и thisArg позволяют применять функцию с задаваемым
// контекстом к каждому элементу.