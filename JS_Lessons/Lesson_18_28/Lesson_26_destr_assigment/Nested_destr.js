// Вложенная деструктуризация

// Если объект или массив содержит другие вложенные объекты или массивы,
// то мы можем использовать более сложные шаблоны с левой стороны,
// чтобы извлечь более глубокие свойства.

// В приведённом ниже коде options хранит другой объект в свойстве size и массив в свойстве items.
// Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные из них:

let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
  size: { // положим size сюда
    width,
    height
  },
  items: [item1, item2], // добавим элементы к items
  title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut

// Весь объект options, кроме свойства extra, которое в левой части отсутствует,
// присваивается в соответствующие переменные:
// В итоге у нас есть width, height, item1, item2 и title со значением по умолчанию.
// Заметим, что переменные для size и items отсутствуют, так как мы взяли сразу их содержимое.

// Умные параметры функций

// Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны.
// Это особенно верно для пользовательских интерфейсов. Представьте себе функцию, которая создаёт меню.
// Она может иметь ширину, высоту, заголовок, список элементов и так далее.
// Вот так – плохой способ писать подобные функции:

function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}

// В реальной жизни проблема заключается в том, как запомнить порядок всех аргументов.
// Обычно IDE пытаются помочь нам, особенно если код хорошо документирован, но всё же…
// Другая проблема заключается в том, как вызвать функцию, когда большинство параметров
// передавать не надо, и значения по умолчанию вполне подходят.
//
// Разве что вот так?

// undefined там, где подходят значения по умолчанию
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])

// Это выглядит ужасно. И становится нечитаемым, когда мы имеем дело с большим количеством параметров.
//
// На помощь приходит деструктуризация!
//
// Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:

// мы передаём объект в функцию
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...и она немедленно извлекает свойства в переменные
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);

// Мы также можем использовать более сложное деструктурирование с вложенными объектами и двоеточием:

let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width присваиваем в w  (что : куда) = по умолчанию если нет данных
  height: h = 200, // height присваиваем в h  (что : куда) = по умолчанию если нет данных
  items: [item1, item2] // первый элемент items присваивается в item1, второй в item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);

// Полный синтаксис – такой же, как для деструктурирующего присваивания:

// function({
//   incomingProperty: varName = defaultValue
//   ...
// })

// Тогда для объекта с параметрами будет создана переменная varName для свойства
// с именем incomingProperty по умолчанию равная defaultValue.

// Пожалуйста, обратите внимание, что такое деструктурирование подразумевает,
// что в showMenu() будет обязательно передан аргумент. Если нам нужны все значения по умолчанию,
// то нам следует передать пустой объект:

// showMenu({}); // ок, все значения - по умолчанию

// showMenu(); // так была бы ошибка

// Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров:

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200

// В приведённом выше коде весь объект аргументов по умолчанию равен {},
// поэтому всегда есть что-то, что можно деструктурировать.

// Итого

//     - Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.
//
//     - Полный синтаксис для объекта:
//
//          let {prop : varName = default, ...rest} = object
//          Свойства, которые не были упомянуты, копируются в объект rest.
//
//      - Полный синтаксис для массива:
//
//           let [item1 = default, item2, ...rest] = array
//              первый элемент отправляется в item1,
//              второй отправляется в item2,
//              все остальные элементы попадают в массив rest.
//
//      - Можно извлекать данные из вложенных объектов и массивов,
//          для этого левая сторона должна иметь ту же структуру, что и правая.