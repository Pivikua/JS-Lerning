// Деструктуризация массива

// Пример деструктуризации массива:

// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"]

// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor

// Теперь мы можем использовать переменные вместо элементов массива.

// Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

let [firstName, surname] = "Ilya Kantor".split(' ');


// «Деструктурирующее присваивание» не уничтожает массив.
// Оно вообще ничего не делает с правой частью присваивания,
// его задача – только скопировать нужные значения в переменные.
// Это просто короткий вариант записи:

// let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];

// Пропускайте элементы, используя запятые
// Ненужные элементы массива также могут быть отброшены через запятую:

// второй элемент не нужен
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
alert( title ); // Consul

// В примере выше второй элемент массива пропускается, а третий присваивается переменной title,
// оставшиеся элементы массива также пропускаются (так как для них нет переменных).
// Работает с любым перебираемым объектом с правой стороны
// Мы можем использовать любой перебираемый объект, не только массивы:

let [a, b, c] = "abc";
let [one, two, three] = new Set([1, 2, 3]);

// Мы можем использовать что угодно «присваивающее» с левой стороны.

// Например, можно присвоить свойству объекта:

let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya

// Цикл с .entries()

// В предыдущей главе мы видели метод Object.entries(obj).

// Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:

let user = {
  name: "John",
  age: 30
};

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, затем age:30
}

// …то же самое для map:

let user = new Map();
user.set("name", "John");
user.set("age", "30");

for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, затем age:30
}

// Остаточные параметры «…»
//
// Если мы хотим не просто получить первые значения, но и собрать все остальные,
// то мы можем добавить ещё один параметр, который получает остальные значения,
// используя оператор «остаточные параметры» – троеточие ("..."):

let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar

// Обратите внимание, что `rest` является массивом.
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2

// Переменная rest является массивом из оставшихся элементов.
// Вместо rest можно использовать любое другое название переменной, просто убедитесь,
// что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.

// Значения по умолчанию
// Если в массиве меньше значений, чем в присваивании, то ошибки не будет.
// Отсутствующие значения считаются неопределёнными:

let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined

// Если нам необходимо указать значения по умолчанию, то мы можем использовать =

// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // Anonymous (значение по умолчанию)

// Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями.
// Они выполняются, только если значения отсутствуют.
//
// Например, здесь мы используем функцию prompt для указания двух значений по умолчанию.
// Но она будет запущена только для отсутствующего значения:

// prompt запустится только для surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // результат prompt