// Итого
//
// Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.
//
//     Объявление:
//
    // квадратные скобки (обычно)
    let arr = [item1, item2];

    // new Array (очень редко)
    let arr = new Array(item1, item2);

//     Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.
//
//     Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется автоматически методами массива.
//
//     Если мы уменьшаем length вручную, массив укорачивается.
//
// Мы можем использовать массив как двустороннюю очередь, используя следующие операции:
//
//     push(...items)добавляет items в конец массива.
//     pop() удаляет элемент в конце массива и возвращает его.
//     shift() удаляет элемент в начале массива и возвращает его.
//     unshift(...items) добавляет items в начало массива.
//
// Чтобы пройтись по элементам массива:
//
//     for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
//     for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
//     for (let i in arr) – никогда не используйте для массивов!

// ----------------------------------------- //
// ---------------- splice() --------------- //
// ----------------------------------------- //

// Метод arr.splice(str) – это универсальный метод для работы с массивами.
// Умеет всё: добавлять, удалять и заменять элементы.
//
// Его синтаксис:
//
// arr.splice(index[, deleteCount, elem1, ..., elemN])
//
// - начинает с позиции index,
// - удаляет deleteCount элементов
// - вставляет elem1, ..., elemN на их место
// - возвращает массив из удалённых элементов.

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// Удаление
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); // осталось ["Я", "JavaScript", "прямо", "сейчас"]

// Удаление с заменой
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

// Здесь видно, что splice возвращает массив из удалённых элементов:
// удалить 2 первых элемента
let removed = arr.splice(0, 2);
alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов

// Метод splice также может вставлять элементы без удаления,
// для этого достаточно установить deleteCount в 0:

let arr = ["Я", "изучаю", "JavaScript"];

// с позиции 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

// Отрицательные индексы разрешены
//
// В этом и в других методах массива допускается использование отрицательного индекса.
// Он позволяет начать отсчёт элементов с конца, как тут:

let arr = [1, 2, 5];

// начиная с индекса -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5

// ----------------------------------------- //
// ---------------- slice() ---------------- //
// ----------------------------------------- //

// синтаксис:
//
// arr.slice([start], [end])
//
// Он возвращает новый массив, в который копирует элементы,
// начиная с индекса start и до end (не включая end).
// Оба индекса start и end могут быть отрицательными.
// В таком случае отсчёт будет осуществляться с конца массива.

let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)
alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)

// slice можно использовать вообще без аргументов: arr.slice() создаёт копию массива arr.

// ----------------------------------------- //
// ---------------- concat() --------------- //
// ----------------------------------------- //

// синтаксис:

// arr.concat(arg1, arg2...)

// Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
// В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…
// Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.

let arr = [1, 2];

// создать массив из: arr и [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6

// если объект имеет специальное свойство Symbol.isConcatSpreadable,
// то он обрабатывается concat как массив: вместо него добавляются его числовые свойства.
//
// Для корректной обработки в объекте должны быть числовые свойства и length:

let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё

// ----------------------------------------- //
// ---------------- forEach() -------------- //
// ----------------------------------------- //

// синтаксис:
arr.forEach(function(item, index, array) {
    // ... делать что-то с item
});

/*
    item – очередной элемент.
    index – его индекс.
    array – сам массив.
*/

// Зпускает функцию для каждого элемента массива
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

// или сложнее

["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
    alert(`${item} имеет позицию ${index} в ${array}`);
});

//               Поиск в массиве             //
// ----------------------------------------- //
// ---- indexOf/lastIndexOf и includes() --- //
// ----------------------------------------- //

// синтаксис:
arr.indexOf(item, from); // ищет item, начиная с индекса from, и возвращает индекс,
// на котором был найден искомый элемент, в противном случае -1.
arr.lastIndexOf(item, from); // то же самое, но ищет справа налево.
arr.includes(item, from); // ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

let arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
alert( arr.includes(1) ); // true

// Обратите внимание, что методы используют строгое сравнение ===.
// Таким образом, если мы ищем false, он находит именно false, а не ноль.

// ----------------------------------------- //
// ------------ find и findIndex ----------- //
// ----------------------------------------- //

// синтаксис:
let result = arr.find(function(item, index, array) {
    // если true - возвращается текущий элемент и перебор прерывается
    // если все итерации оказались ложными, возвращается undefined
});

/*
    item – очередной элемент.
    index – его индекс.
    array – сам массив.
*/

// Если функция возвращает true, поиск прерывается и возвращается item.
// Если ничего не найдено, возвращается undefined

let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);
alert(user.name); // Вася

// Метод arr.findIndex – возвращает индекс, на котором был найден элемент,
// и -1, если ничего не найдено.

// ----------------------------------------- //
// ----------------- filter ---------------- //
// ----------------------------------------- //

// синтаксис:
let results = arr.filter(function(item, index, array) {
    // если true - элемент добавляется к результату, и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
});

/*
    item – очередной элемент.
    index – его индекс.
    array – сам массив.
*/

let users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);
alert(someUsers.length); // 2

//           Преобразование массива          //
// ----------------------------------------- //
// ------------------ map() ---------------- //
// ----------------------------------------- //

// синтаксис:
let result = arr.map(function(item, index, array) {
    // возвращается массив результатов выполнения этой функции
});

/*
    item – очередной элемент.
    index – его индекс.
    array – сам массив.
*/

let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6

// ----------------------------------------- //
// ---------------- sort(fn) --------------- //
// ----------------------------------------- //

// По умолчанию элементы сортируются как строки.
// Чтобы использовать наш собственный порядок сортировки,
// нам нужно предоставить функцию в качестве аргумента arr.sort().

function compareNumeric(a, b) {
    if (a > b) return 1;    // если первое значение больше второго
    if (a == b) return 0;   // если равны
    if (a < b) return -1;   // если первое значение меньше второго
}

let arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15

// Функция сравнения может вернуть любое число
//
// На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше»,
// и отрицательное число, чтобы сказать «меньше».
//
// Это позволяет писать более короткие функции:

let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15

// Помните стрелочные функции? Можно использовать их здесь для того,
// чтобы сортировка выглядела более аккуратной:

arr.sort( (a, b) => a - b );

// Будет работать точно так же, как и более длинная версия выше.

// ----------------------------------------- //
// ---------------- reverse() -------------- //
// ----------------------------------------- //

// Метод меняет порядок элементов в arr на обратный.
// Он также возвращает массив arr с изменённым порядком элементов.
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1

// ----------------------------------------- //
// ------- split(delim) и join(glue) ------- //
// ----------------------------------------- //

// split(delim) разбивает строку на массив по заданному разделителю delim

let names = 'Вася, Петя, Маша';  //строка
let arr = names.split(', ');  // массив имен из строки
for (let name of arr) {   // перебор массива
    alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася...
}
// или через forEach со стрелочной функцией
arr.forEach((item) => {alert( `Сообщение получат: ${name}.` )});

// У метода split есть необязательный второй числовой аргумент –
// ограничение на количество элементов в массиве.
let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
alert(arr); // Вася, Петя

// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:
let str = "тест";
alert( str.split('') ); // т,е,с,т

// join(glue) делает в точности противоположное split.
// Он создаёт строку из элементов arr, вставляя glue между ними.
let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша

// ----------------------------------------- //
// ----------- reduce/reduceRight ---------- //
// ----------------------------------------- //

// Методы arr.reduce и arr.reduceRight похожи на forEach и map, но они немного сложнее.
// Они используются для вычисления какого-нибудь единого значения на основе всего массива.

// синтаксис:
let value = arr.reduce(function(previousValue, item, index, array) {
    // ...
}, [initial]);

/*
    previousValue – результат предыдущего вызова этой функции,
                    равен initial при первом вызове (если передан initial),
    item – очередной элемент массива,
    index – его индекс,
    array – сам массив.
*/

// Проще всего понять на примере.
// Тут мы получим сумму всех элементов массива всего одной строкой:

let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15

// Здесь мы использовали наиболее распространённый вариант reduce,
// который использует только 2 аргумента.

// Давайте детальнее разберём, как он работает.

//     При первом запуске sum равен initial (последний аргумент reduce), то есть 0,
//          а current – первый элемент массива, равный 1.
//          Таким образом, результат функции равен 1.
//     При втором запуске sum = 1, и к нему мы добавляем второй элемент массива (2).
//     При третьем запуске sum = 3, к которому мы добавляем следующий элемент, и так далее…

// В виде таблицы, где каждая строка –- вызов функции на очередном элементе массива:
// 	                sum 	current 	result
// первый вызов 	0 	        1 	        1
// второй вызов 	1 	        2 	        3
// третий вызов 	3 	        3 	        6
// четвёртый вызов 	6 	        4 	        10
// пятый вызов 	    10 	        5 	        15

// можем опустить начальное значение:
let arr = [1, 2, 3, 4, 5];
// убрано начальное значение (нет 0 в конце)
let result = arr.reduce((sum, current) => sum + current);
alert( result ); // 15

// ----------------------------------------- //
// -------------- Array.isArray ------------ //
// ----------------------------------------- //

alert(Array.isArray({})); // false - объект
alert(Array.isArray([])); // true - массив

// ----------------------------------------- //
// ---------------- thisArg ---------------- //
// ----------------------------------------- //

// синтаксис этих методов:
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент

// используем метод объекта army как фильтр, и thisArg передаёт ему контекст:

let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// найти пользователей, для которых army.canJoin возвращает true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23

// Если бы мы в примере выше использовали просто users.filter(army.canJoin),
// то вызов army.canJoin был бы в режиме отдельной функции, с this=undefined.
// Это тут же привело бы к ошибке.
//
// Вызов users.filter(army.canJoin, army) можно заменить на
// users.filter(user => army.canJoin(user)), который делает то же самое.
// Последняя запись используется даже чаще, так как функция-стрелка более наглядна.

// Шпаргалка по методам массива:
//
//     Для добавления/удаления элементов:
//         push (...items)      – добавляет элементы в конец,
//         pop()                – извлекает элемент с конца,
//         shift()              – извлекает элемент с начала,
//         unshift(...items)    – добавляет элементы в начало.
//         splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов
//                                              и вставляет items.
//         slice(start, end)    – создаёт новый массив, копируя в него элементы с позиции start до end
//                                  (не включая end).
//         concat(...items)     – возвращает новый массив: копирует все члены текущего массива
//                                  и добавляет к нему items. Если какой-то из items является
//                                  массивом, тогда берутся его элементы.
//
//     Для поиска среди элементов:
//         indexOf/lastIndexOf(item, pos)   – ищет item, начиная с позиции pos, и возвращает его индекс
//                                              или -1, если ничего не найдено.
//         includes(value)                  – возвращает true, если в массиве имеется элемент value,
//                                              в противном случае false.
//         find/filter(func)                – фильтрует элементы через функцию и отдаёт первое/все
//                                              значения, при прохождении которых через функцию возвращается true.
//         findIndex                        - похож на find, но возвращает индекс вместо значения.
//
//     Для перебора элементов:
//         forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
//
//     Для преобразования массива:
//         map(func)    – создаёт новый массив из результатов вызова func для каждого элемента.
//         sort(func)   – сортирует массив «на месте», а потом возвращает его.
//         reverse()    – «на месте» меняет порядок следования элементов на противоположный
//                          и возвращает изменённый массив.
//         split/join   – преобразует строку в массив и обратно.
//         reduce(func, initial) – вычисляет одно значение на основе всего массива,
//                          вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
//
//     Дополнительно:
//         Array.isArray(arr) проверяет, является ли arr массивом.
//
// Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.
//
// Изученных нами методов достаточно в 99% случаев, но существуют и другие.
//
//     arr.some(fn)/arr.every(fn) проверяет массив.
//
//     Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.
//
//     arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.
//
//     arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target (перезаписывает существующие).